<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link href="./style.css" rel="stylesheet"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Mulish&display=swap" rel="stylesheet">
</head>
<body>
  <h1>Groking Algorithm</h1>

  <div class="short-description">
    <h2>Короткое описание Алгоритмов</h2>

    <p>
      Алгоритм - это пошаговая инструкция для решения задачи.
    </p>

    <h3>
      "O" большое
    </h3>
    <p>
      "O" бльшое - это описание того как выростает количество операций, которое требуется для решения,
      с возростанием количества входных данных для обработки.

      По сути это скорость работы алгоритма.
      Только имеется ввиду не скорость в секундах.

      А прогноз на то какое максимальное количество операций нужную для решения задачи с определенным
      количеством входных параметров.
    </p>
  </div>

  <main>
    <section class="o_list line_box">
      <h3>Самые часто встречающиеся примеры</h3>

      <button class="show_examples">Показать</button>
      <button class="hide_examples">Скрыть</button>

      <ol class="examples_list">
        <li>
          <h4>O(n)</h4>

          <p>
            Линейная скорость - показывает линейную зависимость.
            То есть на n входных параметоров требуется n операций.
          </p>
        </li>

        <li>
          <h4>
            O(log n)
          </h4>

          <p>
            Логарифмическая скорость - показывает что для решения алгоритма потребуется
            логарифм от n параметров.
            Логарифм - это по сути действие противоположное возведению в степень. 
            В случае с О большим всегда подразумевается логарифм от двух.
          </p>
        </li>
        <li>
          <h4>
            O(n * log n)
          </h4>

          <p>
            Это пример эффективных алгоритмов сортировки.
          </p>
        </li>
        <li>
          <h4>
            O(n<sup>2</sup>)
          </h4>

          <p>
            Это пример медленных алгоритмов сортитровки
          </p>
        </li>
        <li>
          <h4>
            O(n!)
          </h4>

          <p>
            Пример очень медленных алгоритмов.

            Алгоритм с такой скоростью применяется например для решемия задачи о комивояжере. 
            Когда нужно найти самый короткий маршрут при путешествии между n количеством городов. 
            Количество операций при таком подходе стремительно растет с увеличением количества городов. 
            такой алгоритм имеет факториальную скорость.
          </p>
        </li>
      </ol>
    </section>

    <section class="binary_search line_box">
      <h3>Бинарный Поиск</h3>

      <p>
        Идея бинарного поиска состоит в том чтобы начинать искать с середины списка(массива).
        ВАЖНО: Бинарный поиск работает только с ОТСОРТИРОВАНЫМ СПИСКОМ!
      </p>

      <p>
        В процессе бинарного поиска мы должны после каждой операции давать один из трех ответов. 
        Текущее значение:
        Больше,
        Меньше,
        Оно самое). 
      </p>

      <p>
        Таким образом мы каждую операцию отбрасываем половину ненужных значений.
        Что значителоно ускоряет наш алгоритм.
      </p>

      <p>
        Скорость Бинарного Поиска составляет <strong>O(log n)</strong>.
      </p>

      <div class="binary">
        <label for="">
          Длинна массива :
          <input type="number" id="array_length">
        </label>
        
        <label for="">
          Искомое число :
          <input type="number" id="search_number">
        </label>

        <br/>

        <button class="binary_find">Искать</button>
        
        <p>
          Количество операций: 
          <span class="attempt_amount">0</span>
        </p>

        <p>
          Индекс искомого эллемента: 
          <span class="search_index">0</span>
        </p>
      </div>
    </section>

    <section class="selection_sort line_box">
      <h3>
        Сортировка Выбором
      </h3>

      <p>
        Сортировка выбором - используется дла упрорядочивания неотсортированых списков
      </p>

      <p>
        При таком подходе к сортировке мы пробегаемся по всей структуре, ищем нужный(самый большой или маленький)
        эллемент и добавляем его в новый список.
        Таким образом за одну операцию нужно пройти все эллементы списка.
        И таких операций будет столько, сколько эллементов имеет список. 
      </p>

      <p>
        Соответственно скорость данного алгоритма будет <strong>O(n<sup>2</sup>)</strong>
      </p>

      <div class="selection-sort">
        <label for="selection_sort_input">
          Введите набор чисел и мы отсортирунм его с помощю алгоритма выбором
        </label>

        <input type="text" id="selection_sort_input"></input>

        <p>
          Отсортированый список элеиентов
        </p>

        <pre id="selection_sort_pre"></pre>

        <button class="selection_sort_btn">Сортировка</button>
      </div>
    </section>

    <section class="selection_sort line_box">
      <h3>Рекурсия и Стек</h3>

      <button class="show_recursion">Показать</button>
      <button class="hide_recursion">Скрыть</button>

      <div class="recursion_article">
        <p>Рекурсия - это случай когда функция вызывает сама сабя.</p>

        <p>Она лежит в основе многих алгоритмов.</p>

        <p>Есть хорошее ваырвжение про рекурсию...</p>

        <blockquote>
          "Циклы могут ускорить работу программы, а рекурсия может ускорить работу программиста.
          Выбирайте что важнее в Вашей ситуации!"
        </blockquote>

        <p>
          Когда функция вызывает сама себя, то по не осторожности можно зделать так что она зациклится.
          Например напишем рекурсивную функцию обратного отсчета...
        </p>

        <pre>
          function countdown(i) {
            console.log(i);

            countdown(i - 1);
          };
        </pre>

        <p>
          При запуске данного примера функция будет выводить в консоль числа в порядке убывания
          пока не переполнится Стек Вызовов(об этом чуть позже...)
        </p>

        <p>
          Это происходит потому что каждая рекурсивная функция состоит из двух частей
        </p>

        <ol>
          <li>Базовый случай - когда работа функции прирывается и происходит выход из рекурсии для предотвращения зацикливания</li>
          <li>Рекурсивный случай - когда функция снова проваливается в рекурсивный вызов</li>
        </ol>

        <p>
          Правилная рекурсивная функция будет выглядеть так...
        </p>

        <pre>
          function countdown(i) {
            console.log(i);

            if(i <= 0) {
              return;
            };

            countdown(i - 1);
          };
        </pre>

        <h4>Стек</h4>

        <p>
          Стек это тоже список задач. Но в отличии от масивов и связаных списков он работает куда проще.
        </p>

        <p>
          Стек напоминает стопку листов с задачами.
          Новые задачи добавляются в верх сиписка и извлекаются от тоуда же.
        </p>

        <p>
          Он работает по принципу: Первый зашел, последний вышел.
        </p>

        <P>
          Стек очень важен в программировании и понимании рекурсии.
        </P>

        <p>
          Стек взовов - это место в котором хранятся вызовы функций.
          Кргда функция работает рекурсивно, под каждый ее вызов будет выделятся новое место в памяти для хранения всех переменных связаных
          с этим вызовом.
        </p>

        <p>
          Этим и обясняется то что слишком меого рекурсивных вызовов могут существенно нагрузить память компютера.
        </p>
      </div>

      <p>
        Здесь можно посмотреть как работает стек взовов с рекурсивными функциями
      </p>

      <p>
        Для примера мы будем запускать функцию вычисления факториала
      </p>

      <pre>
        function factorial(x) {
          if(x == 1) {
            return 1;
          };

          return x * factorial(x - 1);
        };
      </pre>

      <label for="">
        Введите число для вычислений

        <input 
          type="number"
          class="factorial_input_value"
        >
      </label>

      <button class="play_factorial_animation">
        Го факториалить
      </button>

      <p>
        (Для избежания сильной нагрузки число ограничено в диапазоне от 0 до 10)
      </p>

      <div class="factorial_animation">
        <div class="factorial_function">
          <pre>
            function factorial(<span class="factorial_x">x</span>) {
          </pre>

          <pre>
              if(<span class="factorial_x">x</span> == 1) {
                return 1;
              };
          </pre>

          <pre>
              return <span class="factorial_x">x</span> * factorial(<span class="factorial_x">x</span> - 1);
            }
          </pre>
        </div>
        <div class="stack">
          <h4>Stack</h4>

          <ul class="stack_animation">
            <!-- <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li> -->
            <!-- <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>2</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>3</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>4</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li>
            <li>
              <div>fact</div>
              <div>x</div>
              <div>1</div>
            </li> -->
          </ul>
        </div>
      </div>
    </section>
  </main>

  <script src="./script.js"></script>
</body>
</html>

